#!@PYTHON@
# -*- python -*-

import sys, os, pprint, traceback, re, collections

DEBUG = False

# trace:
def trace (msg) :
    if DEBUG :
        sys.stderr.write('los-gentypes: %s\n' % msg)

# print_exception:
def print_exception (exc_info=None, f=None) :
    if f is None : f = sys.stderr
    fmt = format_exception(exc_info)
    f.writelines(fmt)
    f.flush()

# format_exception:
def format_exception (exc_info=None) :
    if exc_info is None :
        exc_info = sys.exc_info()
    tp, exc, tb = exc_info
    xtb = traceback.extract_tb(tb)
    # format tb
    rows = []
    wcols = (0, 0)
    for fn, ln, fc, co in reversed(xtb) :
        fn = os.path.realpath(fn)
        c0 = '%s:%d:%s%s' % (fn, ln, fc, ('' if fc[0] == '<' else '()'))
        c1 = co
        rows.append((c0, c1))
        wcols = (max(wcols[0], len(c0)), max(wcols[1], len(c1)))
    # title
    title = '%s: %s' % (tp.__name__, exc)
    #
    width = max(len(title), sum(wcols) + 4)
    sep1 = ('=' * width) + '\n'
    sep2 = ('-' * width) + '\n'
    out = [sep1, title+'\n', sep2]
    rowfmt = '%%-%ds -- %%s\n' % (wcols[0])
    for r in rows :
        out.append(rowfmt % r)
    out.append(sep1)
    return out

# Token:
class Token :

    # __init__:
    def __init__ (self, tp, val='') :
        self.tp = tp
        self.val = val

    # __repr__:
    def __repr__ (self) :
        return '<%s "%s">' % (self.tp, self.val.replace('\n', '\\n'))

# Lexer:
class Lexer :

    TOKEN_SPECS = (
        ('SPC', r'[ \t\n\f\r]+'),
        ('ID', r'[a-zA-Z_][a-zA-Z0-9_]*'),
        ('COLONCOLON', r'::'),
        ('OPENBRACE',  r'\{'),
        ('CLOSEBRACE', r'\}'),
        ('OPENPAR', r'\('),
        ('CLOSEPAR', r'\)'),
        ('SEMICOLON', r';'),
        ('COLON', r':'),
    )

    KEYWORDS = set((
        'namespace',
        'class',
        'extern',
    ))

    LEXER = re.compile('|'.join('(?P<%s>%s)' % (n, r)
                                for n, r in TOKEN_SPECS))

    LEX = LEXER.match

    LOCATION = re.compile(r'#\s*(?P<L>\d+)\s+"(?P<F>[^"]*)".*')

    # __init__:
    def __init__ (self, f) :
        self.fin = f
        self.tokbuf = [] # tokens buffer
        self.pos = 0     # current charno
        self.buffer = '' # line buffer

    # lex:
    def lex (self, tp=None, val=None) :
        if self.tokbuf :
            tok = self.tokbuf.pop()
        else :
            while True :
                tok = self.__lex()
                if tok.tp != 'SPC' :
                    break
        assert tp is None or tp == tok.tp, (tok, tp)
        assert val is None or val == tok.val, (tok, val)
        return tok

    # unlex:
    def unlex (self, tok) :
        self.tokbuf.append(tok)

    # look:
    def look (self) :
        tok = self.lex()
        self.unlex(tok)
        return tok

    # __lex:
    def __lex (self) :
        # feed the buffer
        while self.pos >= len(self.buffer) :
            self.pos = 0
            self.buffer = self.fin.readline()
            if not self.buffer :
                return Token('END')
            # cpp location tracking
            m = Lexer.LOCATION.match(self.buffer)
            if m is not None :
                # trace("[TODO] location: '%s'" % self.buffer.rstrip('\n'))
                self.buffer = ''
        # get the next token
        m = Lexer.LEX(self.buffer, self.pos)
        assert m is not None, "``%s''" % self.buffer[self.pos:].replace('\n', '\\n')
        assert m.start() == self.pos
        tp = m.lastgroup
        val = self.buffer[self.pos:m.end()]
        self.pos = m.end()
        # fix keywords
        if tp == 'ID' and val in Lexer.KEYWORDS :
            tp = val.upper()
        return Token(tp, val)

# Id:
class Id :

    # __init__:
    def __init__ (self, cml, low, up) :
        self.cml = cml
        self.low = low
        self.up = up
        self.strip = low.replace('_', '')
        
# CIdent:
class CIdent :

    # [fixme] handle '_' and digits
    RE_CMLWORD = re.compile(r"[A-Z]+[a-z]*")
    
    @staticmethod
    def split_cml (ident) :
        words = []
        pos = 0
        while pos < len(ident) :
            m = CIdent.RE_CMLWORD.match(ident, pos)
            assert m is not None, (ident, ident[pos:])
            words.append(ident[pos:m.end()])
            pos = m.end()
        return words
        
    # __init__:
    def __init__ (self, parent, spec) :
        self.parent = parent
        self.spec = spec
        cml_words = CIdent.split_cml(spec)
        self.sfx = Id(''.join(cml_words),
                      '_'.join(w.lower() for w in cml_words),
                      '_'.join(w.upper() for w in cml_words))
        if parent is None :
            assert spec == '', spec # [fixme]
            self.qual = '::'
            self.pfx = self.sfx = self.full = Id('', '', '')
        else :
            if parent.parent is None :
                self.qual = parent.qual + spec
                self.pfx = Id('', '', '')
                self.full = Id(self.sfx.cml,
                               self.sfx.low,
                               self.sfx.up)
            else :
                self.qual = parent.qual + '::' + spec
                self.pfx = Id(cml=parent.full.cml,
                              low=parent.full.low + '_',
                              up =parent.full.up  + '_')
                self.full = Id(cml=parent.full.cml + self.sfx.cml,
                               low=parent.full.low + '_' + self.sfx.low,
                               up =parent.full.up  + '_' + self.sfx.up)
        trace("ident: '%s' + '%s'" % (('<None>' if parent is None else parent.full.cml), spec))
        trace(" > %s" % self.full.cml)
        trace(" > %s" % self.full.low)
        trace(" > %s" % self.full.up)

# Node:
class Node :
    pass

# NList:
class NList (Node) :
    pass

# NDecl:
class NDecl (Node) :

    # __init__:
    def __init__ (self, ctxt, name, extern=False) :
        self.ctxt = ctxt # [fixme] ref-cycle ?
        self.name = name
        self.extern = extern
        if ctxt is None :
            self.ident = CIdent(None, self.name)
        else :
            ctxt._add(self)
            self.ident = CIdent(ctxt.ident, self.name)
            
# NNamespace:
class NNamespace (NDecl) :

    # __init__:
    def __init__ (self, ctxt, name, extern=False) :
        NDecl.__init__(self, ctxt, name, extern=extern)
        self.body = []

    # _add:
    def _add (self, decl) :
        self.body.append(decl)

    # get_decl:
    def get_decl (self, name) :
        for d in self.body :
            if d.name == name :
                return d
        return None

# NClass:
class NClass (NDecl) :

    # __init__:
    def __init__ (self, ctxt, name, base, extern=False) :
        NDecl.__init__(self, ctxt, name, extern=extern)
        self.base = base
        self.has_instance_init = False
        self.has_class_init = False

# Parser:
class Parser :

    # init:
    def init (self, f) :
        self.lexer = Lexer(f)
        self.lex = self.lexer.lex
        self.unlex = self.lexer.unlex
        self.look = self.lexer.look
        # root namespace
        self.root_nspc = NNamespace(None, '')
        # L namespace
        self.l_nspc = NNamespace(self.root_nspc, 'L', extern=True)
        # LObject class
        self.l_object_class = NClass(self.l_nspc, 'Object', base=None, extern=True)
        
    # parse:
    def parse (self, f) :
        self.init(f)
        ast = self.parse_input()
        return ast

    # parse_input:
    def parse_input (self) :
        while True :
            tok = self.look()
            if tok.tp == 'END' :
                break
            elif tok.tp == 'NAMESPACE' :
                self.parse_namespace(self.root_nspc)
            else :
                assert 0, tok
        return self.root_nspc

    # parse_namespace:
    def parse_namespace (self, ctxt) :
        self.lex('NAMESPACE')
        tok_name = self.lex('ID')
        node = NNamespace(ctxt, tok_name.val)
        self.lex('OPENBRACE')
        isextern = False
        while True :
            tok = self.look()
            if tok.tp == 'CLOSEBRACE' :
                break
            elif tok.tp == 'EXTERN' :
                isextern = True
                self.lex('EXTERN')
            elif tok.tp == 'CLASS' :
                self.parse_class(node, isextern=isextern)
                isextern = False
            else :
                assert 0, tok
        self.lex('CLOSEBRACE')

    # parse_class:
    def parse_class (self, ctxt, isextern) :
        self.lex('CLASS')
        tok_name = self.lex('ID')
        # base clause
        tok = self.look()
        if tok.tp == 'COLON' :
            base = self.parse_base_clause(ctxt)
        else :
            base = self.l_object_class
        # create node
        node = NClass(ctxt, tok_name.val, base=base, extern=isextern)
        # body
        tok = self.look()
        if tok.tp == 'OPENBRACE' :
            self.parse_class_body(node)
        self.lex('SEMICOLON')

    # parse_base_clause:
    def parse_base_clause (self, ctxt) :
        self.lex('COLON')
        base = self.parse_qual_type(ctxt)
        return base

    # parse_qual_type:
    def parse_qual_type (self, ctxt) :
        tplist = []
        tplist.append(self.lex('ID').val)
        while True :
            tok = self.look()
            if tok.tp == 'COLONCOLON' :
                self.lex()
            else :
                break
            tplist.append(self.lex('ID').val)
        tp = self._find_rel_type(ctxt, tplist)
        return tp

    def _find_rel_type (self, ctxt, tplist) :
        # [FIXME]
        match = []
        c = ctxt
        while c :
            tp = self._find_type(c, tplist)
            if tp is not None :
                match.append(tp)
            c = c.ctxt
        if len(match) == 0 :
            assert 0, "type not found: %s" % '::'.join(tplist)
        elif len(match) > 1 :
            assert 0, "ambiguous type name: %s" % '::'.join(tplist)
        return match[0]

    def _find_type (self, base, tplist) :
        c = base
        for t in tplist :
            # [FIXME]
            if not isinstance(c, NNamespace) :
                return None
            c = c.get_decl(t)
            if c is None :
                return None
        return c
    
    # parse_class_body:
    def parse_class_body (self, ctxt) :
        self.lex('OPENBRACE')
        while True :
            tok = self.look()
            if tok.tp == 'CLOSEBRACE' :
                self.lex()
                break
            else :
                self.parse_method(ctxt)

    # parse_method:
    def parse_method (self, ctxt) :
        # [TODO]
        self.lex('ID', 'void')
        tok_name = self.lex('ID')
        self.lex('OPENPAR')
        self.lex('CLOSEPAR')
        self.lex('SEMICOLON')
        #
        name = tok_name.val
        if name == 'init' :
            ctxt.has_instance_init = True
        elif name == 'class_init' :
            ctxt.has_class_init = True
        else :
            assert 0, name

# ASTContext:
class ASTContext :

    parent = property(lambda s: s.__parent)
    
    # __init__:
    def __init__ (self, parent=None) :
        self.__parent = parent
        self.__attrs = {}
        
    # __getattr__:
    def __getattr__ (s, n) :
        if n[0] == '_' :
            return object.__getattr__(s, n)
        else :
            try: return s.__attrs[n]
            except KeyError: return getattr(s.__parent, n)

    # __setattr__:
    def __setattr__ (s, n, v) :
        if n[0] == '_' :
            object.__setattr__(s, n, v)
        else :
            s.__attrs[n] = v

# WSection:
class WSection :

    # __init__:
    def __init__ (self) :
        self.nodes = []
        self.children = {}

    # dump:
    def dump (self, f) :
        for n in self.nodes :
            n.dump(f)

    # add_child:
    def add_child (self, name) :
        assert name not in self.children
        child = WSection()
        self.nodes.append(child)
        self.children[name] = child

    # write:
    def write (self, *lines) :
        for l in lines :
            self.nodes.append(WText(l))

# WText:
class WText :

    # __init__:
    def __init__ (self, text) :
        self.text = text

    # dump:
    def dump (self, f) :
        f.write(self.text)
        
# Writer:
class Writer :

    # __init__:
    def __init__ (self) :
        self.root = WSection()

    # dump_file:
    def dump_file (self, fname) :
        tmpfile = fname + '.tmp'
        with open(tmpfile, 'wt') as f :
            self.dump(f)
        if (not os.path.exists(fname)) or Writer.cmpfile(fname, tmpfile) :
            trace(' + %s' % fname)
            os.rename(tmpfile, fname)
        else :
            trace(' - %s' % fname)
            os.unlink(tmpfile)

    @staticmethod
    def cmpfile (file1, file2) :
        with open(file1, 'rt') as f1 :
            with open(file2, 'rt') as f2 :
                while True :
                    l1 = f1.readline()
                    l2 = f2.readline()
                    if l1 != l2 :
                        return 1
                    if l1 == '' :
                        return 0

    # dump:
    def dump (self, f) :
        self.root.dump(f)
        
    # sections:
    def sections (self, *sections) :
        for path in sections :
            dot = path.rfind('.')
            if dot < 0 :
                parent = self.root
                name = path
            else :
                parent = self.get_section(path[:dot])
                name = path[dot+1:]
            parent.add_child(name)

    # get_section:
    def get_section (self, path) :
        sec = self.root
        if path :
            for comp in path.split('.') :
                sec = sec.children[comp]
        return sec
    
    # write:
    def write (self, secpath, *lines) :
        sec = self.get_section(secpath)
        sec.write(*lines)
            
# ASTProcessor:
class ASTProcessor :

    # __init__:
    def __init__ (self) :
        self.files = {}

    # open_file:
    def open_file (self, fname) :
        assert fname not in self.files, fname
        f = Writer()
        self.files[fname] = f
        return f

    # process:
    def process (self, ast) :
        trace("processing ast...")
        self.context = ASTContext()
        self.context.ident = None
        self.visit(ast)
        trace("output...")
        for fname, writer in self.files.items() :
            trace(" => '%s'" % fname)
            writer.dump_file(fname)
        trace("all done!")

    # visit:
    def visit (self, ast) :
        tpname = ast.__class__.__name__.lower()
        # push context
        self.context = ASTContext(self.context)
        # visit
        hdlr = getattr(self, 'visit_' + tpname)
        hdlr(ast)
        # accept
        hdlr = getattr(self, 'accept_' + tpname)
        for child in hdlr(ast) :
            self.visit(child)
        # pop context
        self.context = self.context.parent

    # visit_nnamespace:
    def visit_nnamespace (self, n) :
        trace("namespace: '%s'" % n.ident.qual)

    # accept_nnamespace:
    def accept_nnamespace (self, ast) :
        for n in ast.body : yield n

    # visit_nclass:
    def visit_nclass (self, n) :
        trace("class: '%s'" % n.ident.qual)
        if n.extern :
            return
        ident = n.ident
        hfile = self.context.hfile = self.open_file(n.ident.full.strip + '-def.h')
        ifile = self.context.ifile = self.open_file(n.ident.full.strip + '.inl')
        # header sections
        hfile.sections('defines')
        hfile.sections('typedefs')
        hfile.sections('fndecls')
        # inl sections
        ifile.sections('header')
        ifile.sections('defines')
        ifile.sections('fndecls')
        ifile.sections('fndefs')
        ifile.sections('fndefs.class_init')
        ifile.sections('fndefs.class_init.head')
        ifile.sections('fndefs.class_init.body')
        ifile.sections('fndefs.class_init.foot')
        ifile.sections('fndefs.init')
        ifile.sections('fndefs.init.head')
        ifile.sections('fndefs.init.body')
        ifile.sections('fndefs.init.foot')
        # parent_class macro
        ifile.write('defines',
                    '#define parent_class (%sCLASS_%s)\n' %
                    (n.base.ident.pfx.up, n.base.ident.sfx.up))
        # instance header macro
        hfile.write('defines',
                    '#define %s_INSTANCE_HEADER %s __l_instance_super\n' %
                    (n.ident.full.up, n.base.ident.full.cml))
        # class header macro
        hfile.write('defines',
                    '#define %s_CLASS_HEADER %sClass __l_class_super\n' %
                    (n.ident.full.up, n.base.ident.full.cml))
        # class define
        hfile.write('defines',
                    '#define %sCLASS_%s (%s_get_class())\n' %
                    (ident.pfx.up, ident.sfx.up, ident.full.low))
        # cast macros
        hfile.write('defines',
                    '#define %s(obj) (L_OBJECT_CHECK_INSTANCE_CAST((obj), %sTYPE_%s, %s))\n' %
                    (ident.full.up, ident.pfx.up, ident.sfx.up, ident.full.cml))
        # check instance type macro
        hfile.write('defines',
                    '#define %sIS_%s(obj) (L_OBJECT_CHECK_INSTANCE_TYPE((obj), %sCLASS_%s))\n' %
                    (ident.pfx.up, ident.sfx.up, ident.pfx.up, ident.sfx.up))
        # get_class macro
        hfile.write('defines',
                    '#define %s_GET_CLASS(obj) (L_OBJECT_GET_CLASS_CAST((obj), %sTYPE_%s, %sClass))\n' %
                    (ident.full.up, ident.pfx.up, ident.sfx.up, ident.full.cml))
        # instance/class typedefs
        hfile.write('typedefs',
                    'typedef struct _%s %s;\n' % (n.ident.full.cml, n.ident.full.cml),
                    'typedef struct _%sClass %sClass;\n' % (n.ident.full.cml, n.ident.full.cml))
        # class_init handler
        ifile.write('fndecls',
                    'static void __%s_class_init ( LObjectClass *cls );\n' % ident.full.low)
        ifile.write('fndefs.class_init.head',
                    'static void __%s_class_init ( LObjectClass *cls )\n' % ident.full.low,
                    '{\n')
        ifile.write('fndefs.class_init.foot',
                    '}\n')
        if n.has_class_init :
            ifile.write('fndecls',
                        'static void %s_class_init ( LObjectClass *cls );\n' % ident.full.low)
            ifile.write('fndefs.class_init.body',
                        '  %s_class_init(cls);\n' % ident.full.low)
        # instance_init handler
        ifile.write('fndecls',
                    'static void __%s_init ( LObject *obj );\n' % ident.full.low)
        ifile.write('fndefs.init.head',
                    'static void __%s_init ( LObject *obj )' % ident.full.low,
                    '{\n')
        ifile.write('fndefs.init.foot',
                    '}\n')
        if n.has_instance_init :
            ifile.write('fndecls',
                    'static void %s_init ( LObject *obj ); \n' % ident.full.low)
            ifile.write('fndefs.init.body',
                    '  %s_init(obj);\n' % ident.full.low)
        # get_class func
        hfile.write('fndecls',
                    'LObjectClass *%s_get_class ( void );\n' % ident.full.low)
        ifile.write('fndefs',
                    'LObjectClass *%s_get_class ( void )\n' % ident.full.low,
                    '{\n',
                    '  static LObjectClass *cls = NULL;\n',
                    '  if (!cls) {\n',
                    '    LClassInfo info = {\n',
                    '      sizeof(%sClass),\n' % ident.full.cml,
                    '      __%s_class_init,\n' % ident.full.low,
                    '      sizeof(%s),\n' % ident.full.cml,
                    '      __%s_init,\n' % ident.full.low,
                    '    };\n'
                    '    cls = l_object_class_register("%s", %sCLASS_%s, &info);\n' %
                    (ident.full.cml, n.base.ident.pfx.up, n.base.ident.sfx.up),
                    '  }\n',
                    '  return cls;\n',
                    '}\n')
                    

    # accept_nclass:
    def accept_nclass (self, n) :
        # [fixme]
        if 0 : yield None
        
# main:
def main () :
    try:
        _main()
    except:
        print_exception()
        sys.exit(1)

# _main:
def _main () :
    trace('hello!')
    # parse input
    parser = Parser()
    ast = parser.parse(sys.stdin)
    # trace("AST:\n%s" % pprint.pformat(ast))
    # process the AST
    visitor = ASTProcessor()
    visitor.process(ast)

# exec
if __name__ == '__main__' :
    main()
