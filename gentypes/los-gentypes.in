#!@PYTHON@
# -*- python -*-

import sys, os, pprint, traceback, re, collections

# trace:
def trace (msg) :
    sys.stderr.write('los-gentypes: %s\n' % msg)

# print_exception:
def print_exception (exc_info=None, f=None) :
    if f is None : f = sys.stderr
    fmt = format_exception(exc_info)
    f.writelines(fmt)
    f.flush()

# format_exception:
def format_exception (exc_info=None) :
    if exc_info is None :
        exc_info = sys.exc_info()
    tp, exc, tb = exc_info
    xtb = traceback.extract_tb(tb)
    # format tb
    rows = []
    wcols = (0, 0)
    for fn, ln, fc, co in reversed(xtb) :
        fn = os.path.realpath(fn)
        c0 = '%s:%d:%s%s' % (fn, ln, fc, ('' if fc[0] == '<' else '()'))
        c1 = co
        rows.append((c0, c1))
        wcols = (max(wcols[0], len(c0)), max(wcols[1], len(c1)))
    # title
    title = '%s: %s' % (tp.__name__, exc)
    #
    width = max(len(title), sum(wcols) + 4)
    sep1 = ('=' * width) + '\n'
    sep2 = ('-' * width) + '\n'
    out = [sep1, title+'\n', sep2]
    rowfmt = '%%-%ds -- %%s\n' % (wcols[0])
    for r in rows :
        out.append(rowfmt % r)
    out.append(sep1)
    return out

# Token:
class Token :

    # __init__:
    def __init__ (self, tp, val='') :
        self.tp = tp
        self.val = val

    # __repr__:
    def __repr__ (self) :
        return '<%s "%s">' % (self.tp, self.val.replace('\n', '\\n'))

# Lexer:
class Lexer :

    TOKEN_SPECS = (
        ('SPC', r'[ \t\n\f\r]+'),
        ('ID', r'[a-zA-Z_][a-zA-Z0-9_]*'),
        ('OPENBRACE',  r'\{'),
        ('CLOSEBRACE', r'\}'),
        ('SEMICOLON', r';'),
    )

    KEYWORDS = set((
        'namespace',
        'class',
    ))

    LEXER = re.compile('|'.join('(?P<%s>%s)' % (n, r)
                                for n, r in TOKEN_SPECS))

    LEX = LEXER.match

    LOCATION = re.compile(r'#\s*(?P<L>\d+)\s+"(?P<F>[^"]*)".*')

    # __init__:
    def __init__ (self, f) :
        self.fin = f
        self.tokbuf = [] # tokens buffer
        self.pos = 0     # current charno
        self.buffer = '' # line buffer

    # lex:
    def lex (self, tp=None, val=None) :
        if self.tokbuf :
            tok = self.tokbuf.pop()
        else :
            while True :
                tok = self.__lex()
                if tok.tp != 'SPC' :
                    break
        assert tp is None or tp == tok.tp, (tok, tp)
        assert val is None or val == tok.val, (tok, val)
        return tok

    # unlex:
    def unlex (self, tok) :
        self.tokbuf.append(tok)

    # look:
    def look (self) :
        tok = self.lex()
        self.unlex(tok)
        return tok

    # __lex:
    def __lex (self) :
        # feed the buffer
        while self.pos >= len(self.buffer) :
            self.pos = 0
            self.buffer = self.fin.readline()
            if not self.buffer :
                return Token('END')
            # cpp location tracking
            m = Lexer.LOCATION.match(self.buffer)
            if m is not None :
                trace("[TODO] location: '%s'" % self.buffer.rstrip('\n'))
                self.buffer = ''
        # get the next token
        m = Lexer.LEX(self.buffer, self.pos)
        assert m is not None, "``%s''" % self.buffer[self.pos:].replace('\n', '\\n')
        assert m.start() == self.pos
        tp = m.lastgroup
        val = self.buffer[self.pos:m.end()]
        self.pos = m.end()
        # fix keywords
        if tp == 'ID' and val in Lexer.KEYWORDS :
            tp = val.upper()
        return Token(tp, val)

# AST node types:
def ast_class (clsname, tpname, fields) :
    base = collections.namedtuple(clsname+'_Base', ('loc',) + fields)
    cls = type(clsname, (base,), {
        'tp': tpname,
    })
    return cls

ASTNamespace = ast_class('ASTNamespace',
                         'namespace',
                         ('name',
                          'body'))

ASTClass = ast_class('ASTClass',
                     'class',
                     ('name',
                      'body'))

# Parser:
class Parser :

    # init:
    def init (self, f) :
        self.lexer = Lexer(f)
        self.lex = self.lexer.lex
        self.unlex = self.lexer.unlex
        self.look = self.lexer.look
        
    # parse:
    def parse (self, f) :
        self.init(f)
        ast = self.parse_input()
        return ast

    # parse_input:
    def parse_input (self) :
        body = []
        while True :
            tok = self.look()
            if tok.tp == 'END' :
                break
            elif tok.tp == 'NAMESPACE' :
                body.append(self.parse_namespace())
            else :
                assert 0, tok
        return ASTNamespace((), '', tuple(body))

    # parse_namespace:
    def parse_namespace (self) :
        body = []
        self.lex('NAMESPACE')
        tok_name = self.lex('ID')
        self.lex('OPENBRACE')
        while True :
            tok = self.look()
            if tok.tp == 'CLOSEBRACE' :
                break
            elif tok.tp == 'CLASS' :
                body.append(self.parse_class())
            else :
                assert 0, tok
        self.lex('CLOSEBRACE')
        return ASTNamespace((), tok_name.val, tuple(body))

    # parse_class:
    def parse_class (self) :
        body = []
        self.lex('CLASS')
        tok_name = self.lex('ID')
        # self.lex('OPENBRACE')
        # self.lex('CLOSEBRACE')
        self.lex('SEMICOLON')
        return ASTClass((), tok_name.val, tuple(body))

# ASTProcessor:
class ASTProcessor :

    # process:
    def process (self, ast) :
        trace("processing ast...")
        self.visit(ast)

    # visit:
    def visit (self, ast) :
        hdlr = getattr(self, 'visit_' + ast.tp)
        hdlr(ast)

    # visit_namespace:
    def visit_namespace (self, ast) :
        trace("namespace: %s" % repr(ast))
        for n in ast.body :
            self.visit(n)

    # visit_class:
    def visit_class (self, ast) :
        trace("class: %s" % repr(ast))
        for n in ast.body :
            self.visit(n)
        
# main:
def main () :
    try:
        _main()
    except:
        print_exception()
        sys.exit(1)

# _main:
def _main () :
    trace('hello!')
    # parse input
    parser = Parser()
    ast = parser.parse(sys.stdin)
    trace("AST:\n%s" % pprint.pformat(ast))
    # process the AST
    visitor = ASTProcessor()
    visitor.process(ast)
    assert 0

# exec
if __name__ == '__main__' :
    main()
